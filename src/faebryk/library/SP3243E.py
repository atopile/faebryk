# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

import logging

import faebryk.library._F as F  # noqa: F401
from faebryk.libs.library import L  # noqa: F401
from faebryk.libs.picker.picker import DescriptiveProperties
from faebryk.libs.units import P  # noqa: F401

logger = logging.getLogger(__name__)


class SP3243E(F.RS232_3D5R_Tranceiver):
    """
    Common base module for RS232 tranceivers
    """

    # ----------------------------------------
    #     modules, interfaces, parameters
    # ----------------------------------------
    voltage_doubler_charge_pump_power: F.ElectricPower
    """Terminal of the voltage doubler charge-pump capacitor """
    inverting_charge_pump_power: F.ElectricPower
    """Terminal of the inverting charge-pump capacitor """
    positive_charge_pump_power: F.ElectricPower
    """Regulated +5.5V output generated by the charge pump """
    negative_charge_pump_power: F.ElectricPower
    """Regulated -5.5V output generated by the charge pump """
    power: F.ElectricPower
    """Power input to the module"""

    enable: F.ElectricLogic
    online: F.ElectricLogic
    status: F.ElectricLogic

    # ----------------------------------------
    #                 traits
    # ----------------------------------------
    designator_prefix = L.f_field(F.has_designator_prefix_defined)("U")
    datasheet = L.f_field(F.has_datasheet_defined)(
        "https://assets.maxlinear.com/web/documents/sp3243e.pdf"
    )

    @L.rt_field
    def descriptive_properties(self):
        return F.has_descriptive_properties_defined(
            {
                DescriptiveProperties.manufacturer: "MaxLinear",
                DescriptiveProperties.partno: "SP3243EBEA-L/TR",
            },
        )

    def __preinit__(self):
        # ------------------------------------
        #           connections
        # ------------------------------------
        for pwr in self.get_children(direct_only=True, types=F.ElectricPower):
            cap = pwr.decoupled.decouple()
            # TODO: min values according to self.power.voltage
            # 3.0V to 3.6V > C_all = 0.1μF
            # 4.5V to 5.5V > C1 = 0.047µF, C2,Cvp, Cvn = 0.33µF
            # 3.0V to 5.5V > C_all = 0.22μF
            #
            cap.capacitance.merge(0.22 * P.uF)
            # cap.rated_voltage.override(F.Range.lower_bound(16 * P.V))
            # TODO: merge conflict

        # ------------------------------------
        #          parametrization
        # ------------------------------------
        self.power.voltage.merge(F.Range(3.0 * P.V, 5.5 * P.V))
